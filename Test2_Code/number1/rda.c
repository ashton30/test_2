/*an rda for test 2 */
//this is my answer to number 6 
#include <stdio.h>
#include <ctype.h>
#include "main.c"

void boolexpr(void);
void statement(void);
/*
  this method provided by Robert W. Sebesta
  R. W. Sebesta, Concepts of Programming Languages. Boston, MA: Pearson, 2016
*/
/* ifstmt
 Parses strings in the language generated by the rule:
 <ifstmt> -> if (<boolexpr>) <statement>
 [else <statement>]
 */
void ifstmt(void) {
  if (nextToken != IF_CODE)
 	  error();
  else {
	  lex();
 	  if (nextToken != LEFT_PAREN)
 		  error();
  	else {
 		  lex();
 		  boolexpr();
 		  if (nextToken != RIGHT_PAREN)
 			  error();
 		  else {
 			  lex();
		 	  statement();
 			  if (nextToken == ELSE_CODE) {
 				  lex();
 				  statement();
 			  }
 		  }
  	}
  }
}

//rest of file coded by me (Ashton Sims)

/*whilestmt 
<while_stmt> → while "( (<boolexpr>) ")" "{" <body> "}"
<body> → <stmt> | <stmt> {<stmt>} */

void whileStmt(void){
  //make sure first token is ‘if’
  if (nextToken != WHILE_CODE)
    error();
  else{
    //call lexical analyzer and get next token
    lex();
    //check for left parenthesis
    if (nextToken != LEFT_PAREN)
      error();
    else{
      //parse Boolean expression
      lex();
      boolexpr();
    //check for right parenthesis
      if (nextToken != RIGHT_PAREN)
        error();
      else{
        //parse the statement
        lex();
        statement();
      }
    }
  }
}

/*blank statement function that checks for a statement */
void statement(void){

}

/*function to recognize logical and mathematical expressions 
<boolexpr> -> IDENT
*/
void boolexpr(void){
  if (nextToken != IDENT){
 	  error();
  }else {
	  lex();
 	  if (nextToken != AND_OP 
        || nextToken != OR_OP 
        || nextToken != NOT_OP 
        || nextToken != ADD_OP 
        || nextToken != SUB_OP
        || nextToken != MULT_OP
        || nextToken != DIV_OP){
 		  error();
  	}else {
 		  lex();
 		  if (nextToken != IDENT){
 			  error();
 		  }else {
 			  lex();
 			}
 		}
  }
}

/*this function recognizes mathematical assignment*/
void assign(void){
  if(nextToken != IDENT){
    error();
  }else{
    lex();
    if (nextToken != ASSIGN_OP){
      error();
    }else{
      lex();
      while (nextToken == IDENT 
            || nextToken == ADD_OP 
            || nextToken == SUB_OP
            || nextToken == MULT_OP
            || nextToken == DIV_OP
            || nextToken == INT_LIT){
		    lex();
		    
	    }
    }
  }
}